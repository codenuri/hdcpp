디자인 패턴 
=> 특정 문제를 해결하기 위해 사용된 전형적인 코딩 기법에 "이름"을 부여 한것
=> GOF's 책에서는 23개의 이름을 소개
=> 대부분의 객체지향 언어로 구현 가능한 일반적인 기법 사용 
=> ex : prototype, template method, strategy

=> 각 언어의 고유 특징(장점)을 잘 나타나지 않음. 

IDioms
=> 각 언어의 문법적 특징을 고려한 디자인 기법
=> C++ IDioms, Java IDioms, C# IDioms
=> 구글 "C++ IDioms" 에서 1번째 링크
=> policy base design

==============================================================================
디자인 패턴의 핵심 원리 #1. 변하지 않은 코드에서 변하는 코드는 분리하는 것

#1. 변하는 코드는 가상함수로 분리
=> 의도 : 파생 클래스를 만들어서 가상함수를 override 하라는 것
=> 예제 : 도형편집기 예제의 draw()/draw_imp()
=> template method


#2. 변하는 코드를 다른 클래스로 분리(정책 클래스)

정책 클래스가 지켜야 하는 규칙을 어떻게 약속하고, 
정책 클래스를 어떻게 교체 가능하게 할것 인가 ?

strategy : 함수 이름을 인터페이스로 약속하고, 인터페이스를 사용해서 교체 가능하게!
policy base design : 함수 이름을 문서화로 약속하고, template 인자를 통해서 교체 가능하게!


							성능				실행시간 교체 가능 여부
strategy 			: 		느리다(가상함수)	 가능
policy base design 	:       빠르다(인라인도가능) 불가능
							템플릿이므로 여러개 
							생성하면 코드메모리
							증가
//---------------------------------------------
// 객체지향 디자인 패턴의 핵심 #2. 재귀적 포함을 많이 사용합니다.

// A 는 B 를 포함하지만 A 자신도 포함합니다.
// => A와 B 는 공통의 기반 클래스 필요

// 왜 ?? "어떤의도"로 재귀적 포함을 사용하는가에 따라 다른 패턴

// composite : 재귀적 포함을 사용한 복합객체 만들기
// decorator : 재귀적 포함을 사용한 객체에 기능 추가

//------------------------------------------------------
// 객체지향 디자인 패턴의 핵심 #3. 문제를 해결하기 위해 간접층 도입

// 왜 ? "어떤 문제를 해결" 하기 위해서 간접층을 도입했는가 ?
// 간접층의 의도 는 무엇인가 ?

// 사용자 ========= ZipDecorator ===========> FileStream
//								간접층의 의도 : 기능의 추가
//								decorator 패턴	

// 사용자 ========= stack  =================> list
//							간접층의 의도 : 인터페이스 변경을 위한 간접층
//							adapter 패턴

// 사용자 ========= BrightnessCommand ======> monitor.set_brightness()
//							간접층의 의도 : 명령의 저장, 취소 등을 위해서
//							command 패턴
// 이외에 
// facade : 사용법을 쉽게 하기 위한 간접층
// bridge : update 를 편리하기 위한 간접층 
// proxy  : 다양한 용도의 여러 장점을 위한 간접층
//-----------------------------------------------
// 디자인 패턴의 핵심 #4. 객체를 생성하는 다양한 방법을 이해하세요
// 특히 "static factory method" 가 아주 널리 사용됩니다.

// 7_객체생성정리
class Rect
{
};

// 객체를 만드는 방법

int main()
{
	// #1. 
	Rect rc1;		// 수명이 정해짐. {} 벗어나면 파괴.

	// #2.
	Rect* rc2 = new Rect;	// 수명이 자유롭다. 원할때 파괴.
							// 자유로운것이 항상 좋은것은 아닙니다.

	// #3. static 멤버 함수를 통한 객체 생성
	// => 안전을 위한 여러가지 제약을 넣을수 있고
	// => 자료구조에 보관도 가능
	// => java 에서 "static factory method" 라고 합니다. 구글 검색해보세요
	Rect* rc3 = Rect::create(); // 오직 한개 객체만 - 싱글톤
								// 속성이 같으면공유 - flyweight
								// 생성함수를 자료구조에 보관도 가능
								// 읽기 좋은 코드  
								// 1. Car c = new Car(Colors::red);
								// 2. Car c = Car::redCar();


	// #4. prototype 패턴
	Rect* rc4 = rc3->clone();

	// #5. 공장에서 제품 생산
	Rect* rc5 = factory.create();

}

// rust 코드
// let s = String::new("hello")   // 여기서 new 는 static 메소드